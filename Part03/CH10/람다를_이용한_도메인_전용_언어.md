# Chapter 10 - 람다를 이용한 도메인 전용 언어

## 1. 도메인 전용 언어(DSL)

**도메인 전용 언어(Domain-Specific Language, DSL)**는 특정 비즈니스 도메인의 문제를 해결하기 위해 만든 언어로, 특정 도메인을 인터페이스로 만든 API라 할 수 있다. 도메인을 표현할 수 있는 클래스와 메서드 집합으로 구성된다.

* 예: SQL은 데이터베이스 내부 구현을 알지 못해도 데이터를 다룰 수 있게 해주는 DSL

### 1.1 DSL의 장단점

**장점**:
- **간결함**: 비즈니스 로직을 간편하게 캡슐화하여 코드를 간결하게 만든다
- **가독성**: 도메인 용어를 사용하여 비 도메인 전문가도 코드를 쉽게 이해할 수 있다
- **유지보수**: 잘 설계된 DSL로 구현한 코드는 쉽게 유지보수할 수 있다
- **높은 수준의 추상화**: 도메인 관련 세부 사항을 숨기고 추상화 수준을 높인다
- **관심사 분리(SoC)**: 비즈니스 로직을 애플리케이션 인프라 관련 코드와 분리할 수 있다

**단점**:
- **설계 어려움**: 도메인 지식을 제한적인 언어에 담기 어렵다
- **개발 비용**: 초기 개발 및 유지보수에 많은 비용과 시간이 소모된다
- **추가 계층**: DSL은 도메인 모델을 감싸는 추가 계층이 된다
- **언어 학습 부담**: 팀이 새 언어를 배워야 하는 부담이 있다
- **호스팅 언어 한계**: 자바와 같은 언어는 장황한 문법으로 사용자 친화적 DSL을 만들기 어렵다

### 1.2 JVM에서 이용할 수 있는 DSL 해결책

1. **내부 DSL**
   - 자바로 구현한 DSL
   - 람다 표현식으로 더 간결하고 표현력 있는 DSL 구현 가능
   - **장점**: 별도 컴파일러 불필요, 자바 IDE 기능 활용, 기존 코드와 호환
   
   ```java
   // 익명 내부 클래스 대신 람다 사용
   numbers.forEach(s -> System.out.println(s));
   ```

2. **다중 DSL**
   - JVM 기반 언어(코틀린, 스칼라, 그루비 등)로 DSL 구현
   - **장점**: 문법적 간결함, 자바 한계 극복
   - **단점**: 언어 지식 필요, 빌드 과정 복잡화, 호환성 문제

3. **외부 DSL**
   - 완전히 독립적인 언어로 설계

## 2. 최신 자바 API의 작은 DSL

자바 API 자체도 작은 DSL을 포함하고 있다:
- **스트림 API**: 컬렉션 조작을 위한 DSL
- **Collectors**: 데이터 수집을 위한 DSL

## 3. 자바로 DSL을 만드는 패턴과 기법

주어진 도메인 예제(주식 거래):
- **Stock**: 주식 시장에서의 주식을 모델링
- **Trade**: 주어진 가격에 주식을 사거나 파는 거래
- **Order**: 고객의 주식 거래 주문

### 3.1 메서드 체인

메서드 호출을 체인으로 연결하여 DSL을 구현하는 방식

```java
Order order = forCustomer("BigBank")
        .buy(80).stock("IBM").on("NYSE").at(125.00)
        .sell(50).stock("GOOGLE").on("NASDAQ").at(375.00)
        .end();
```

**특징**:
- 메서드 이름이 키워드 인수 역할
- 플루언트 API로 구현(메서드가 자기 자신이나 다른 빌더 객체 반환)
- 정해진 순서로 메서드 호출 강제 가능
- **단점**: 구현이 장황하고 많은 접착 코드 필요

### 3.2 중첩된 함수

함수 안에 함수를 중첩하여 도메인 모델을 구성

```java
Order order = order("BigBank",
    buy(80,
        stock("IBM", on("NYSE")),
        at(125.00)),
    sell(50,
        stock("GOOGLE", on("NASDAQ")),
        at(375.00))
);
```

**특징**:
- 함수 중첩으로 도메인 객체 계층 반영
- 구현이 비교적 간단
- **단점**: 많은 괄호 필요, 인수 위치로 의미 정의, 정적 메서드 사용 빈번

### 3.3 람다 표현식을 이용한 함수 시퀀싱

람다 표현식으로 정의한 함수 시퀀스로 DSL 구현

```java
Order order = LambdaOrderBuilder.order(o -> {
  o.forCustomer("BigBank");
  o.buy(t -> {
    t.quantity(80);
    t.price(125.00);
    t.stock(s -> {
      s.symbol("IBM");
      s.market("NYSE");
    });
  });
  o.sell(t -> {
    t.quantity(50);
    t.price(375.00);
    t.stock(s -> {
      s.symbol("GOOGLE");
      s.market("NASDAQ");
    });
  });
});
```

**특징**:
- 플루언트 방식으로 정의 가능
- 람다 중첩으로 도메인 객체 계층 반영
- **단점**: 구현 장황, 람다 문법으로 인한 잡음

### 3.4 여러 패턴 조합하기

DSL 설계 시 여러 패턴을 조합하여 사용 가능

```java
Order order =
    forCustomer("BigBank",
        buy(t -> t.quantity(80)
            .stock("IBM")
            .on("NYSE")
            .at(125.00)),
        sell(t -> t.quantity(50)
            .stock("GOOGLE")
            .on("NASDAQ")
            .at(375.00)));
```

**장점**: 각 패턴의 장점 활용 가능  
**단점**: 사용자가 DSL을 배우는 데 시간 소요

### 3.5 DSL에 메서드 참조 사용하기

세금 계산 같은 기능에 메서드 참조를 활용한 DSL 구현

```java
double value = new TaxCalculator().with(Tax::regional)
        .with(Tax::surcharge)
        .calculateF(order);
```

## 4. DSL 패턴 비교

| 패턴 | 장점 | 단점 |
|------|------|------|
| 메서드 체인 | - 메서드 이름이 키워드 역할<br>- 선택적 파라미터 지원<br>- 순서 강제 가능<br>- 문법적 잡음 최소화 | - 구현이 장황<br>- 빌더 연결 접착 코드 필요 |
| 중첩 함수 | - 구현이 간단<br>- 함수 중첩으로 계층 표현 | - 정적 메서드 많음<br>- 위치로 인수 정의<br>- 선택적 파라미터에 오버로딩 필요 |
| 람다 표현식 | - 선택적 파라미터 지원<br>- 정적 메서드 최소화<br>- 람다 중첩으로 계층 표현 | - 구현이 장황<br>- 람다 문법 잡음 |

결론적으로, 특정 도메인 문제를 해결하기 위해 DSL을 사용할 때는 적절한 패턴을 선택하거나 조합하여 사용하는 것이 중요하다. 