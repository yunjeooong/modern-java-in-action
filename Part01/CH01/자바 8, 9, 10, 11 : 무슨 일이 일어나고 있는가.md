# Part01

## ch01 자바 8,9,10.11 : 무슨일이 일어나고 있는

- 자바는 처음부터 다양한 유용한 라이브러리를 포함한 잘 설계된 객체지향 언어로 출발했다.
  코드를 JVM 바이트코드로 컴파일하는 특징 덕분에, 자바는 한때 인터넷 애플릿 프로그램의 주요 언어가 되었다.
  JVM이 지속적으로 발전하면서, JVM 위에서 실행되는 다른 언어들도 더 부드럽게 실행될 수 있었고,
  자바와의 상호 운용성도 가능해졌다. 이와 함께 자바는 데스크톱뿐 아니라 임베디드 컴퓨팅 분야까지 영역을 넓혀갔다.
- 그러나 프로그래밍 언어 생태계에도 변화의 바람이 불었다. 빅데이터의 등장으로, 프로그래머들은 멀티코어 컴퓨터나 컴퓨팅 클러스터를 활용해 방대한 데이터를 효과적으로 처리해야 할 필요성에 직면했다.
  병렬 처리를 적극적으로 활용해야 했지만, 기존의 자바로는 이러한 요구를 충분히 감당하기 어려웠다.
- 이에 따라 자바는 변화했다. 자바 8은 새로운 프로그래밍 도구들을 도입하며,
- 다양한 문제를 더 빠르고 정확하게, 그리고 유지보수하기 쉽게 해결할 수 있도록 했다.
- 자바 8에 추가된 기능들은 기존 자바에는 없던 완전히 새로운 개념이었지만,
  현대 개발 환경에서 요구되는 기능들을 효과적으로 제공해냈다.

## 1.1 역사의 흐름은 무엇인가?

### 자바 역사의 흐름과 변화

자바는 버전이 올라감에 따라 다양한 기능이 추가되며 **더 쉽고, 안전하고, 효율적인 프로그램 구현이 가능**해졌다.
특히 **자바 8**은 역사상 가장 큰 변화를 이끈 버전으로 평가된다.

---

### 자바 주요 버전별 변화 요약


| 버전    | 주요 특징                                                       | 비고                                              |
| ------- | --------------------------------------------------------------- | ------------------------------------------------- |
| **1.0** | 스레드(thread), 락(lock), 메모리 모델(memory model) 지원        | 저수준 기능 제공 → 일반 개발자에겐 다루기 어려움 |
| **5**   | 스레드 풀(thread pool), 병렬 컬렉션(concurrent collection) 도입 | 병렬 처리 도구 강화                               |
| **7**   | 포크/조인(Fork/Join) 프레임워크 도입                            | 병렬 처리 지원 강화, 여전히 복잡함                |
| **8**   | **스트림 API**, **람다**, **디폴트 메소드** 도입                | 자바 역사상 가장 큰 변화                          |
| **9**   | **리액티브 스트림 표준화**                                      | RxJava를 표준으로 수용                            |

---

### 3. 자바 8의 핵심 변화

#### 병렬 처리의 새로운 접근

- **배경**: 멀티코어 CPU의 대중화
- 기존 방식: 스레드 직접 제어 → 복잡하고 에러 유발
- 자바 8: **스트림 API**와 **람다식**으로 간단하게 병렬 처리 가능

사과 목록 무게순 정렬하는 예시를 통새서 그전의 자바와 자바8의 차이를 살펴보자면,

**Before**

```java

Collection.sort(inventory, new Comparator<Apple>(){
    public int compare(Apple apple1, Apple apple2){
        return; apple1,getWeight(),compareTo(apple2.getWeightt());
    }
}
```

**After**

```java
inventory.sort(Comparator.comparing(Apple::getWeight));
```

### 자바 8이 제공하는 주요 기술


| 기능                       | 설명                                                       |
| -------------------------- | ---------------------------------------------------------- |
| **스트림 API**             | 간결한 코드로 병렬 연산 가능.`synchronized` 없이 병렬 처리 |
| **람다 표현식**            | 동작을 파라미터로 전달 가능. 코드 간결성 향상              |
| **디폴트 메소드**          | 인터페이스에 구현 메소드 정의 가능. 유연성 향상            |
| **함수형 프로그래밍 지원** | 코드 전달 및 조합 가능 → 고급 추상화 가능                 |

정리하자면
•	복잡한 병렬처리 → 직관적이고 간결한 코드
•	멀티코어 프로세서의 활용을 일반 개발자도 쉽게 할 수 있도록 지원
•	에러 가능성 감소 및 생산성 향상을 위한 기능 지속 추가

⸻

## 1.2. 왜 아직도 자바는 변화하는가?

우리는 시공을 초월하는 완벽한 언어를 원하지만, 현실적으로 그런 언어는 존재하지 않는다.
모든 언어는 장단점을 가지고 있다.

### 예시 비교


| 언어     | 장점                                                | 단점                                |
| -------- | --------------------------------------------------- | ----------------------------------- |
| C, C++   | 작은 런타임 풋프린트 → OS/임베디드 시스템에서 인기 | 낮은 프로그래밍 안전성, 보안 취약성 |
| Java, C# | 안전성 ↑ → 중대형 애플리케이션에서 우위           | 런타임 풋프린트 크기 ↑             |

> 새로운 언어가 등장하면, 진화하지 않는 언어는 사장됨.
> 그러나 Java는 1995년 첫 베타 공개 이후 강력한 생태계를 구축하며 살아남음.

---

### 1.2 프로그래밍 언어 생태계와 Java

#### Java의 출발

- 잘 설계된 객체지향 언어로 시작 (라이브러리 풍부)
- 스레드, 락 등 초기 동시성 지원
- JVM 바이트 코드 컴파일 → 인터넷 시대의 Applet 언어로 부상
- 스마트카드, 토스터, 셋톱박스 등 임베디드 컴퓨팅 분야에서 성공

#### 참고

- Scala, Groovy는 JVM 기반 언어로, 바이트코드를 통해 Java 대체 가능
- JVM의 발전 → 다른 언어들도 JVM에서 더 부드럽게 실행되고 상호운용 가능

### 1.3 Java와 객체지향

- **1990년대**: 객체지향이 두 가지 이유로 주목
  - 캡슐화 → 소프트웨어 엔지니어링 문제 감소
  - WIMP(Windows, Icons, Menus, Pointer) 프로그래밍과의 조화
- Java Applet → 대학에 도입 → 졸업생들이 Java로 개발 시작
- 하드웨어 발전 → 실행시간보다 개발시간이 중요해지며 Java 채택 증가

### 3 Java가 직면한 새로운 과제

#### 1) 병렬 프로세싱

- TB급 데이터, 멀티코어, 클러스터 환경 요구 증가
- Java 8: 새로운 프로그래밍 도구 제공 → 병렬성 강화

#### 2) 대규모 시스템 설계

- 다양한 외부 컴포넌트 통합 사례 증가
- Java 8: `default method`
- Java 9: `module system` 도입

---

### 1.2.2. Stream Processing (스트림 처리)

### stream이란?

> 한 번에 한 개씩 처리되는 연속적인 데이터 항목들의 집합

- 프로그램: 입력 스트림(System.in) → 처리 → 출력 스트림(System.out)

### Unix 예시

```bash
cat file1 file2 | tr "[A-Z]" "[a-z]" | sort | tail -3
```

•	cat, tr, sort, tail 등이 병렬 파이프라인 처리

#### Java 8에서의 스트림 처리

•	java.util.stream 패키지
•	Stream<T>: T 타입 요소의 연속된 흐름
•	고수준 파이프라인 조합 가능 (DB 쿼리처럼 선언적)
•	여러 CPU 코어로 쉽게 병렬 처리 가능 → 스레드 없이도 병렬성 확보

⸻

### 1.2.3. Behavior Parameterization (동작 파라미터화)

#### 개념

실행 방법을 나중에 정하는 코드 블럭을 메서드에 전달하는 방식
즉, 메서드를 메서드의 인수로 넘겨줌

#### Java 8 이전

- 메서드를 메서드로 전달할 방법 없음 → 복잡한 익명 클래스 사용

#### Java 8 이후

- 동작 파라미터화 가능 → 람다, 메서드 참조 활용
- 프로그래밍 도입

👉🏻 중요: Stream API의 기본 개념이 바로 이 동작 파라미터화!

### 1.2.4. Shared Mutable Data & Parallelism (공유 가변 데이터와 병렬성)

#### 공짜 병렬성?

- 스트림 메서드로 전달하는 코드의 동작 방식을 조금 바꾸면 병렬성을 공짜로 얻을 수 있음

#### 문제점

•
- 공유 변수/객체 존재 시 병렬성 깨짐 → 동기화 필요
- schronized: 병렬성 지원하나 성능 저하 유발 (특히 멀티코어 환경)

#### 해결책: 스트림 + 순수 함수

- 상태 없는 함수(stateless), 부작용 없는 함수(side-effect-free)
- 가변 상태를 피하면 병렬성에 안전
- 프로그래밍에서 중시되는 개념

### 1.2.5. 자바가 진화해야 하는 이유

#### 변화의 흐름

**버전	주요 변화**

- Java 5:  제네릭 도입 → 타입 안정성 및 가독성 향상
- Java 8:
  - 함수형 프로그래밍 도입 → 작업 중심 코드 작성 가능
  - Iterator → for-each로 간결화
  - 객체지향 + 함수형 패러다임 조화 → 다양한 문제 해결 방식 제공

#### 정리하자면

프로그래밍 언어는 하드웨어 변화, 개발자 요구, 생태계의 진화에 맞춰 변화해야 한다.
자바도 예외가 아니며, 계속해서 적응하고 발전 중이다.

---

## 1.3 자바 함수

프로그래밍 언어에서 함수란 일반적으로 **메서드(특히 정적 메서드)**를 의미한다.
하지만 **자바 8의 함수**는 수학적인 의미를 포함하며, **부작용 없는 함수(pure function)**로 사용된다.

---

### 함수의 값 취급과 일급 시민 개념

#### 일급 시민(First-Class Citizen)이란?

- 미국의 시민권 개념에서 유래
- 변수에 저장하고, 파라미터로 전달하며, 반환할 수 있는 **값**을 말함
  (예: `int`, `double`, `String`)

#### 이급 시민(Second-Class Citizen)

- 메서드나 클래스와 같이 **값처럼 직접 전달할 수 없는 구조체**

#### 목표

> **메서드를 일급 시민으로 다룰 수 있다면**,
> 메서드를 코드 블록으로 전달하는 유용한 프로그래밍이 가능

### 자바 8의 함수 표현 방식

#### 1) 메서드 참조 (`::`)

- 자바 8 이전: 메서드는 객체화해서만 전달 가능
- 자바 8 이후: `::`을 통해 메서드 자체를 함수 인수로 전달 가능

```java
// 자바 8 이전 방식
File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
    public boolean accept(File file) {
        return file.isHidden();
    }
});
```
```java
// 자바 8 이후: 메서드 참조
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```
- File::isHidden는 “이 메서드를 값으로 사용하라”는 의미

⸻

#### 2) 람다 표현식 (익명 함수)

•	자바 8부터 함수도 값으로 취급 가능
•	기존 메서드를 직접 정의하지 않고 람다 문법으로 간결하게 구현 가능

```java
// 함수형 프로그래밍 방식
filterApples(inventory, (Apple a) -> a.getWeight() > 150);
```
이러한 문법을 사용하는 방식을 함수형 프로그래밍이라고 한다.

⸻

### 코드 전달하기: 필터 예제

**기존 방식**

```java
public static List<Apple> filterHeavyApples(List<Apple> inventory) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
        if (apple.getWeight() > 150) {
            result.add(apple);
        }
    }
    return result;
}
```
- 조건이 바뀌면 if 조건만 바뀌고 전체 구조는 반복됨
- & 붙여넣기식의 비효율적인 코드

**자바 8 방식** :조건을 함수로 전달

```java
// 조건 메서드
public static boolean isHeavyApple(Apple apple) {
    return apple.getWeight() > 150;
}

// 조건을 받는 인터페이스
public interface Predicate<T> {
    boolean test(T t);
}

// 조건을 파라미터로 전달받는 필터 메서드
static List<Apple> filterApples(List<Apple> inventory, Predicate<Apple> p) {
    List<Apple> result = new ArrayList<>();
    for (Apple apple : inventory) {
        if (p.test(apple)) {
            result.add(apple);
        }
    }
    return result;
}
```
> #### Predicate란?
>
> •	값을 받아 true/false를 반환하는 함수
>
> • 여러 조건을 검증하기 위해 코드를 복사 & 붙여넣기 하는 방식이 아닌 검증 메서드만 추가로 작성하면 된다.

filterApples() 메서드는
filterApples(inventory, Apple::isHeavyApple)과 같이 호출하여 그 조건을 판별할 수 있다.

⸻

### 람다를 통한 간결한 코드

**조건 메서드 하나하나 정의하는 것이 번거롭다면?**

```java
filterApples(inventory, (Apple a) -> a.getWeight() > 150);
filterApples(inventory, (Apple a) -> GREEN.equals(a.getColor()));
```
둘 다 적용:

```java
filterApples(inventory, (Apple a) -> a.getWeight() > 150 || GREEN.equals(a.getColor()));
```
- 람다가 복잡해지면 메서드 참조로 의미를 분명히 하는 것이 더 좋음

→ 가독성 > 간결성

### 정리


| 개념                  | 설명                                                       |
| --------------------- | ---------------------------------------------------------- |
| **일급 시민**         | 변수처럼 다룰 수 있는 값. 람다/메서드를 함수처럼 전달 가능 |
| **메서드 참조 (::)**  | 기존 메서드를 값처럼 전달할 수 있는 자바 8 기능            |
| **람다 표현식**       | 익명 함수로 함수형 스타일 구현                             |
| **Predicate**         | 조건을 표현하는 함수형 인터페이스 (Boolean 반환)           |
| **함수형 프로그래밍** | 함수 자체를 값으로 전달하는 방식. 재사용성과 유연성 ↑     |

---

## 1.4. 스트림 (Stream)

거의 모든 자바 애플리케이션은 **컬렉션**을 활용하지만, **모든 문제를 해결하기엔 한계**가 있다.

예를 들어, 고가의 트랜잭션만 필터링하고 이를 통화(currency)별로 그룹화하는 경우를 살펴보자.

---

### 컬렉션 기반 코드 예시

```java
Map<Currency, List<Transaction>> transactionsByCurrencies = new HashMap<>();

for (Transaction transaction : transactions) {
    if (transaction.getPrice() > 100) {
        Currency currency = transaction.getCurrency();
        List<Transaction> transactionsForCurrency = transactionsByCurrencies.get(currency);

        if (transactionsForCurrency == null) {
            transactionsForCurrency = new ArrayList<>();
            transactionsByCurrencies.put(currency, transactionsForCurrency);
        }

        transactionsForCurrency.add(transaction);
    }
}
```
- 중첩된 제어 흐름이 많고 가독성 낮음
- 코드 반복 → 유지보수 어려움

### 스트림 API 활용 코드

```java
Map<Currency, List<Transaction>> transactionsByCurrencies =
    transactions.stream()
        .filter(t -> t.getPrice() > 100)
        .collect(groupingBy(Transaction::getCurrency));
```
지금은 스트림 API를 활용하면 컬렉션 API와는 상당히 다른 방식으로 데이터를 처리 할 수 있다는 사실만 기억하자!

컬렉션에서는 반복 과정을 개발자가 직접 처리해야 한다.
예를 들어 for-each 문을 사용해 각 요소를 하나씩 순회하면서 작업을 수행한다.
이렇게 개발자가 반복을 직접 제어하는 방식을 **외부 반복(external iteration)** 이라고 합니다.

반면, 자바 8의 스트림(Stream) API를 사용하면 이러한 반복 과정을 라이브러리가 대신 처리해준다.
개발자는 어떤 작업을 수행할지만 람다 표현식으로 전달하면, 스트림이 알아서 반복을 수행하고 그 결과를 적절히 저장하거나 반환한다.
이처럼 반복이 라이브러리 내부에서 이루어지는 것을 **내부 반복(internal iteration)** 이라고 부릅니다.

비유를 들자면, 외부 반복은 상자에 물건을 하나씩 직접 담는 것과 같고, 내부 반복은 여러 사람이 동시에 물건을 나눠 담는 것과 같다. 즉, 스트림을 이용하면 동시에 병렬적으로 작업을 수행할 수 있는 구조를 자연스럽게 얻을 수 있다.

이러한 차이는 멀티코어 컴퓨터 환경에서 더욱 두드러진다.
컬렉션을 이용해 방대한 요소를 처리할 경우, 반복이 단일 CPU에서 순차적으로 진행되므로 시간이 오래 걸릴 수 있다.
그러나 스트림을 이용하면 여러 CPU 코어에 작업을 자동으로 분산시켜 병렬 처리를 수행합니다. 예를 들어 8코어 CPU라면 최대 8배 빠른 속도로 작업을 마칠 수 있는 것이다.

따라서 스트림은 단순히 문법적 편의성을 넘어서, 효율성과 성능 향상까지 고려한 고수준 데이터 처리 도구라고 볼 수 있다.

### 1.4.1 멀티 스레딩은 어렵다

과거 자바 버전에서는 병렬성을 구현하려면 직접 스레드를 생성하고 제어해야 했다.
자바가 제공하는 스레드 API를 이용해 멀티스레딩 코드를 작성할 수는 있었지만,
그만큼 복잡하고 까다로웠다. 특히 멀티스레드 환경에서는 여러 스레드가 동시에 하나의 자원에 접근하고 데이터를 변경할 수 있기 때문에,
제어가 제대로 되지 않으면 원치 않는 결과가 발생할 수 있다.

예를 들어 두 개의 스레드가 있고, 이들이 공유하는 정수형 변수 int value = 100이 있다고 가정해보자.

> - 스레드1이 value에 접근해 값을 읽는다. (100)
> - 이어서 스레드2도 같은 시점에 value 값을 읽는다. (100)
> - 스레드1은 이 값을 103으로 증가시키고 저장한다. (+3)
> - 이제 공유 자원의 실제 값은 103이 된다.
> - 하지만 스레드2는 여전히 자신이 읽었던 100을 기준으로 계산을 한다.
> - 스레드2는 100에 +5를 더해 105로 변경하고 저장한다.
> - 결과적으로 최종 값은 105가 된다.

문제는 이 두 연산이 각각 +3, +5를 했으므로, 우리가 기대한 최종값은 108이라는 점이다.
하지만 각 스레드는 자신이 읽은 시점의 값을 기준으로 연산을 했기 때문에, 결과는 108이 아닌 105로 덮여써지게 된다.
이처럼 멀티스레드 환경에서는 순서와 동기화가 중요하며, 조금만 실수가 있어도 오류가 생길 수 있다.

자바 8의 스트림 API는 이런 문제들을 해결하기 위한 새로운 접근을 제시했다.
우선 스트림을 이용하면 복잡하고 반복적인 제어 흐름을 작성하지 않아도 된다.
기존 컬렉션 코드에서는 조건에 따라 데이터를 필터링하고, 추출하고, 그룹화하는 작업마다 비슷한 코드 구조가 반복되었다.
스트림은 이러한 패턴을 단순화시켜 주어진 작업을 선언형으로 표현할 수 있게 해준다.

또한 스트림은 멀티코어 환경에서 병렬 처리를 쉽게 할 수 있도록 지원한다.
예를 들어 두 개의 코어가 있는 컴퓨터에서 스트림을 통해 리스트를 필터링할 경우, 한 CPU는 리스트 앞부분을, 다른 CPU는 뒷부분을 처리하도록 나누어 요청할 수 있다. 이처럼 작업을 나누는 과정을 **포킹(forking)**이라고 하며, 이후 각 코어가 작업을 마친 결과를 하나로 합치는 머징(merging) 과정이 뒤따른다. 이처럼 스트림은 멀티코어를 효율적으로 활용할 수 있는 기반을 제공한다.

**컬렉션**과 **스트림**은 얼핏 비슷해 보일 수 있지만, 그 목적에는 큰 차이가 있다.
컬렉션은 데이터의 저장과 접근에 중점을 두는 반면, 스트림은 데이터에 어떤 계산을 수행할지 기술하는 것에 초점을 맞춘다.
특히 스트림은 내부적으로 병렬 처리를 손쉽게 실행할 수 있도록 설계되어 있어, 함께 사용하는 람다 표현식과 결합하면 병렬성을 ‘공짜로’ 얻을 수 있다.

단, 스트림을 무조건 병렬로 사용하는 것이 항상 좋은 선택은 아니다.
데이터 양이 적을 경우 병렬 처리의 오버헤드로 인해 오히려 성능이 더 나빠질 수도 있다는 점도 고려해야 한다.

```java
// 순차 처리 (병렬 아님)
List<Apple> heavyApples =
inventory.stream()
.filter(a -> a.getWeight() > 150)
.collect(toList());

// 병렬 처리
List<Apple> heavyApples =
inventory.parallelStream()
.filter(a -> a.getWeight() > 150)
.collect(toList());
```
## 1.5. 디폴트 메서드와 자바 모듈

현대 개발 환경에서는 외부에서 만들어진 다양한 컴포넌트를 조합해 시스템을 구축하는 방식이 일반적이다.
하지만 자바 8 이전에는 이러한 요구를 효과적으로 지원하지 못했다.

### 자바 8 이전의 문제점

기존 자바에서는 컴포넌트를 단순한 JAR 파일로 제공했고, 이는 여러 패키지를 묶은 평범한 파일일 뿐이었다.
이러한 구조에서 인터페이스를 수정해야 할 경우, 그 인터페이스를 구현하고 있는 모든 클래스의 구현도 함께 수정해야 했다.
👉🏻 유지보수와 확장에 큰 불편을 초래했다.

### 자바 8과 9의 해결책

**자바 9**: 모듈 시스템 도입

자바 9에서는 이러한 구조적 한계를 극복하기 위해 모듈 시스템이 도입되었다.
모듈 시스템은 여러 패키지를 하나의 모듈 단위로 정의할 수 있는 문법을 제공하며, 다음과 같은 장점이 있다:

- 컴포넌트(JAR)에 구조 부여 가능
- 문서화와 모듈 의존성 확인이 용이
- 보안성 및 구성의 유연성 향상

즉, 이제는 단순한 패키지의 나열이 아니라, 명확하게 정의된 경계와 의존성을 가진 모듈 단위의 개발이 가능해졌다.

### 자바 8: 디폴트 메서드 도입

자바 8은 인터페이스의 유연한 확장을 가능하게 해주는 **디폴트 메서드(default method)** 를 도입하였다.

기존 문제점

- 인터페이스에 메서드를 추가하면,
  그 인터페이스를 구현하는 모든 클래스가 강제로 해당 메서드를 구현해야 했다.

**디폴트 메서드의 해결 방식**

- default 키워드를 통해 인터페이스 안에 메서드 본문을 정의할 수 있다.
- 기존 구현 클래스를 수정하지 않고도 인터페이스를 확장할 수 있다.

예) 
자바 8의 List 인터페이스에 다음과 같은 디폴트 메서드 정의거 추가되었기 떄문에
자바 8에서는 List에 직접 sort 메서드를 호출할 수 있다. 
```java
//자바 8이후 메서드 참조 적용
default void sort(Comparator? super E C) {
Collections.sort(this, c);
}
```

결론적으로 

- 디폴트 메서드는 변화에 유연한 구조를 만들 수 있도록 돕는다.
- 모듈 시스템은 자바 생태계에 구조적 명확성과 보안성을 제공한다.
- 둘 다 공통적으로 유지 관리성 향상과 코드의 **재사용성**, **확장성**을 크게 높이는 역할을 한다.

## 1.6 함수형 프로그래밍에서 가져온 다른 유용한 아이디어

앞서 1.1부터 1.5까지의 내용을 통해 함수형 프로그래밍의 두 가지 핵심 아이디어를 살펴보았다.

1. 메서드와 람다를 일급 값(first-class value)으로 사용하는 것,
2. 가변 공유 상태 없이 병렬 실행을 안전하고 효율적으로 구현하는 것이다.

자바 8의 **Stream API**는 이 두 가지 아이디어를 모두 활용하고 있다.
이처럼 함수형 프로그래밍은 단순히 스타일의 차이를 넘어서, 병렬성과 선언적 프로그래밍, 안전한 코드 작성을 돕는 다양한 개념들을 제공한다.

그중 하나가 **null 회피 기법**이다.
전통적인 자바에서는 null을 잘못 다루면 NullPointerException이 발생하기 쉽다. 
함수형 언어들은 이런 문제를 피하기 위해 명시적인 데이터 형식을 사용하는데, 자바 8에서는 이를 위해 `Optional<T>` 클래스를 도입했다.

`Optional<T>`는 값이 있을 수도, 없을 수도 있는 상황을 명확하게 표현할 수 있도록 돕는 컨테이너 객체이다. 값이 없는 경우를 null 대신 명시적으로 처리하게 하여, 개발자가 의도적으로 없는 상태를 고려하도록 유도하고, 자연스럽게 NullPointerException을 줄여준다.

또한 함수형 프로그래밍 언어들은 **패턴 매칭(pattern matching)** 이라는 강력한 도구를 지원한다. 이는 값을 단순히 비교하는 것이 아니라, 
값의 형태와 구조에 따라 조건을 분기할 수 있게 해준다. 예를 들어 수학에서는 다음과 같은 방식으로 재귀 함수를 정의할 수 있다.

```java
f(0) = 1  
f(n) = n * f(n - 1)
```

자바에서는 이를 if-else나 switch 문을 이용해 구현하겠지만, 함수형 언어에서는 이보다 더 직관적이고 선언적인 방식으로 처리할 수 있다.
예를 들어 Scala에서는 match 키워드를 사용해 트리 구조의 수식을 단순화하는 다음과 같은 예제를 작성할 수 있다:

```java
def simplifyExpression(expr: Expr): Expr = expr match {
case BinOp("+", e, Number(0)) => e
case BinOp("-", e, Number(0)) => e
case BinOp("*", e, Number(1)) => e
case BinOp("/", e, Number(1)) => e
case _ => expr
}
```

위 코드에서 expr match는 자바의 switch(expr)처럼 보이지만, 
단순한 값 비교를 넘어서 데이터 구조의 패턴 자체를 분석하고 분기할 수 있는 기능을 제공한다. 
이처럼 패턴 매칭은 switch문을 확장한 개념으로, 값뿐 아니라 데이터의 구조까지 조건으로 삼을 수 있다.

하지만 자바 8은 이러한 패턴 매칭을 아직 완전히 지원하지는 않는다.
대신 자바에서는 복잡한 조건 분기와 타입 분석을 위해 **Visitor Pattern(방문자 패턴)** 같은 객체지향 설계를 활용해왔다.

Visitor 패턴은 로직과 구조를 분리하는 대표적인 설계 패턴이다.
즉, 실제 로직을 수행하는 객체(Visitor)가 구조를 가진 객체(Element)를 방문하면서 작업을 수행하는 방식이다. 
이 패턴을 이용하면 객체 구조를 변경하지 않고도 새로운 기능을 추가할 수 있으며, 구조와 로직을 분리해 유지보수가 쉬워진다.

#### +) 참고

현재 학습하고 있는 책은 자바 8,9,11에 대해서 다루고 있다. 현재 자바는 자바 23까지 나온 상태이다. 
**자바 17, 자바 21이후 부터는 패턴 매칭 기능을 지원한다**

자바 8 이전에는 객체의 타입에 따라 분기해야 할 때 if-else 문이나 instanceof와 명시적 캐스팅을 반복적으로 사용하는 방식이 일반적이었다. 객체의 구조에 따라 다른 처리를 하고 싶어도, 직접 타입을 판별하고 명시적으로 형 변환한 뒤 작업을 수행해야 했다. 이러한 방식은 코드가 장황해지고 오류 가능성도 높아지는 단점이 있었다.
예를 들어 어떤 도형 객체의 둘레를 계산한다고 할 때, 자바 8 이전 방식은 다음과 같이 작성해야 했다:

```java
if (shape instanceof Rectangle) {
Rectangle r = (Rectangle) shape;
    return 2 * r.getLength() + 2 * r.getWidth();
} else if (shape instanceof Circle) {
Circle c = (Circle) shape;
    return 2 * Math.PI * c.getRadius();
} else {
        throw new IllegalArgumentException("알 수 없는 shape");
}
```
이와 같은 코드는 조건 분기와 형 변환이 반복되며, 코드의 가독성과 유지보수성을 떨어뜨린다.

하지만 자바 17부터는 switch 문에서도 패턴 매칭을 사용할 수 있는 기능이 도입되었고, 
자바 21에서는 이 기능이 정식으로 채택되었다. 
이를 통해 객체의 타입을 검사하고 동시에 형 변환 없이도 처리 로직을 깔끔하게 작성할 수 있게 되었다. 
위의 코드는 자바 21 기준으로 다음과 같이 간결하게 바꿀 수 있다:

```java
return switch (shape) {
        case Rectangle r -> 2 * r.getLength() + 2 * r.getWidth();
    case Circle c    -> 2 * Math.PI * c.getRadius();
default          -> throw new IllegalArgumentException("Unknown shape");
};
```

이러한 **패턴 매칭 기반 switch** 문은 단순한 값 비교를 넘어서,
**객체의 타입과 구조**를 기반으로 분기할 수 있도록 해준다. 
또, 타입에 따라 처리해야 할 로직을 선언적으로 기술할 수 있어, 
함수형 언어에서 지원하던 패턴 매칭의 이점을 자바에서도 누릴 수 있게 되었다.

결과적으로, 자바 21은 자바 8 이전과 달리 복잡한 조건 분기 상황에서 Visitor 패턴 없이도 간결하고 타입 안정적인 코드를 작성할 수 있는 문법적 기반을 제공하게 되었다. 
이는 자바가 함수형 패러다임의 이점을 점차 흡수하며 진화하고 있음을 보여주는 대표적인 사례라 할 수 있다!

